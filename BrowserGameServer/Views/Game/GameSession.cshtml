
@{
    Layout = null;
}

<!DOCTYPE html>

<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <meta charset="utf-8">
    <title>GameSession</title>
</head>
<body>

    @*<div class="testDiv">
                BlaBlaBla
            </div>
        <img src="GetImage/Chessboard.png"/>
        <style>
            img[src="GetImage/Chessboard.png"] {
                display: none;
            }
        </style>*@

    <canvas></canvas>
    <button class="button1">Continue</button>

    <style>
        Canvas {
            position: absolute;
            z-index: -1;
            top: 0px;
            left: 0px;
        }
        .botton1{
            height: 50px;
            width: 100px
        }
    </style>
    
    <script>
        {
            //States----------------------------------------------------------------------
            let GameStates = {
                WaitBegining: "WaitBegining",
                ActiveLeading: "ActiveLeading",
                ActiveWaiting: "ActiveWaiting",
                Winner: "Winner",
                Loser: "Loser",
                Disconnected: "Disconnected"
            }
            let PlayerSides = {
                Black: "Black",
                White: "White"
            }
            //let MoveStates = {
            //    EndMove: "EndMove",
            //    CurrentMove: "CurrentMove"
            //}

            let GameState = GameStates.WaitBegining;
            //let MoveState = MoveStates.CurrentMove;
            let PlayerSide;

            //----------------------------------------------------------------------------

            let canvas = document.querySelector("canvas");
            let context = canvas.getContext("2d");
            context.font = "22px Verdana";
            canvas.width = innerWidth;
            canvas.height = innerHeight;

            class Vector {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                }

                Sum(addition) {
                    if (typeof (addition) === "number") {
                        let x = this.x + addition;
                        let y = this.y + addition;
                        return new Vector(x, y);
                    }
                    else if (typeof (addition) === "object") {
                        let x = this.x + addition.x;
                        let y = this.y + addition.y;
                        return new Vector(x, y);
                    }
                    else return undefined;
                }

                Multiply(multiplier) {
                    if (typeof (multiplier) === "number") {
                        let x = this.x * multiplier;
                        let y = this.y * multiplier;
                        return new Vector(x, y);
                    }
                    else if (typeof (multiplier) === "object") {
                        return this.x * multiplier.x + this.y * multiplier.y;
                    }
                    else return undefined;
                }
            }

            class Table {
                constructor() {
                    this.size = { width: 600, height: 600 };
                    this.position = new Vector(canvas.width / 2 - this.size.width / 2, canvas.height / 2 - this.size.height / 2);

                    this.arrayOfChess = [];

                    this.img = new Image();
                    this.imgIsLoaded = false;
                    this.img.onload = () => {
                        this.imgIsLoaded = true;
                    }
                    this.img.src = "/ChessWeb/Chessboard.png";
                }

                draw() {
                    context.drawImage(this.img, this.position.x, this.position.y, this.size.width, this.size.height);
                }

                update() { }

                addChess(chess) {//под позицией имеется ввиду двойной номер ячейки, а не координаты на холсте
                    this.arrayOfChess.push(chess);
                }
            }

            class Chess {
                constructor(table, tPosition, side) {
                    this.table = table;
                    this.size = { width: table.size.width / 8, height: table.size.height / 8 };

                    this.tablePos = new Vector(tPosition.x, tPosition.y);///

                    this.oldCanvasPos = getCanvasPosition(this, tPosition);
                    this.canvasPosition = getCanvasPosition(this, tPosition);

                    this.side = side;

                    this.table.addChess(this);

                    this.img = new Image();
                    this.imgIsLoaded = false;
                    this.img.onload = () => {
                        this.imgIsLoaded = true;
                    }
                }

                draw() {
                    if (this.imgIsLoaded)
                        context.drawImage(this.img, this.canvasPosition.x, this.canvasPosition.y, this.size.width, this.size.height);
                }

                update() { }
            }

            class Pawn extends Chess {
                constructor(table, tPosition, side) {
                    super(table, tPosition, side);
                    if (side === "Black") {
                        this.img.src = "/ChessWeb/PeshkaB.png";
                    }
                    else {
                        this.img.src = "/ChessWeb/PeshkaW.png";
                    }
                }

                allowedShift(shift_x, shift_y) {
                    //если пешка никуда не ходит
                    if (shift_x === 0 && shift_y === 0)
                        return true;
                    //ходы в бок, назад, либо вперед более чем на 1 клетку недопустимы
                    if ((Math.abs(shift_x) > 0 && shift_y === 0) || shift_y > 1 || shift_y < 0)
                        return false;
                    //двинуться по диагонали если есть фигура и она враг
                    else if (shift_x !== 0 && shift_y !== 0 &&
                        this.table.arrayOfChess.find(a => (a.tablePos.x === this.tablePos.x + shift_x) && (a.tablePos.y === this.tablePos.y + shift_y))) {
                        if (this.table.arrayOfChess.find(a => (a.tablePos.x === this.tablePos.x + shift_x) && (a.tablePos.y === this.tablePos.y + shift_y)).side !== this.side)
                            return true;
                        else
                            return false;
                    }
                    //двинуться вперед если никого нет
                    else if (shift_x === 0 && shift_y !== 0 &&
                        !(this.table.arrayOfChess.find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y + shift_y)))) {
                        return true;
                    }
                    else return false;
                }
            }

            class Queen extends Chess {
                constructor(table, tPosition, side) {
                    super(table, tPosition, side);
                    if (side === "Black") {
                        this.img.src = "/ChessWeb/QueenB.png";
                    }
                    else {
                        this.img.src = "/ChessWeb/QueenW.png";
                    }
                }

                allowedShift(shift_x, shift_y) {
                    //если ход не по диагонали
                    if ((Math.abs(shift_x) !== Math.abs(shift_y)) && (shift_x !== 0 && shift_y !== 0))
                        return false;
                    if (shift_x === 0 && shift_y === 0)
                        return true;


                    //анализ маршрута вниз от движемой фигуры
                    let move_distance_down = 0;
                    if (shift_y > 0 && shift_x === 0) {
                        for (let i = this.tablePos.y; i < 8 && move_distance_down < Math.abs(shift_y); i++) {
                            move_distance_down += 1;
                            if (this.table.arrayOfChess.find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y + move_distance_down))) {
                                //move_distance_down--;
                                break;
                            }
                        }
                        if (shift_y <= move_distance_down &&
                            !this.table.arrayOfChess.find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y + move_distance_down))) {
                            return true;
                        }
                        else if (shift_y <= move_distance_down &&
                            this.table.arrayOfChess.find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y + move_distance_down)).side !== this.side)
                            return true;
                    }

                    //анализ маршрута вверх от движемой фигуры
                    let move_distance_up = 0;
                    if (shift_y < 0 && shift_x === 0) {
                        for (let i = this.tablePos.y; i > 0 && move_distance_up < Math.abs(shift_y); i--) {
                            move_distance_up += 1;
                            if (this.table.arrayOfChess.find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y - move_distance_up))) {
                                //move_distance_up--;
                                break;
                            }
                        }
                        if (Math.abs(shift_y) <= move_distance_up &&
                            !this.table.arrayOfChess.find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y - move_distance_up))) {
                            return true;
                        }
                        else if (Math.abs(shift_y) <= move_distance_up &&
                            this.table.arrayOfChess.find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y - move_distance_up)).side !== this.side)
                            return true;
                    }
                    /*
                            //анализ маршрута вправо от движемой фигуры
                            int move_distance_right = 0;
                            if (shift_y > 0){
                                while (this.y + move_distance_right < this.chess_Board.GetLength(1) - 1){
                                    move_distance_right++;
                                    if (this.chess_Board[this.x, this.y + move_distance_right] != null){
                                        if (this.chess_Board[this.x, this.y + move_distance_right].side == this.side)
                                            move_distance_right--;
                                        break;
                                    }
                                }
                                if (shift_y <= move_distance_right) return true;
                            }

                            //анализ маршрута влево от движемой фигуры
                            int move_distance_left = 0;
                            if (shift_y < 0){
                                while (this.y + move_distance_left > 0){
                                    move_distance_left--;
                                    if (this.chess_Board[this.x, this.y + move_distance_left] != null){
                                        if (this.chess_Board[this.x, this.y + move_distance_left].side == this.side)
                                            move_distance_left++;
                                        break;
                                    }
                                }
                                if (shift_y >= move_distance_left) return true;
                            }

                                //анализ маршрута вниз вправо от движемой фигуры
                            move_distance_down = 0;
                            move_distance_right = 0;
                            if (shift_x > 0 && shift_y > 0)
                            {
                                while (this.x + move_distance_down < this.chess_Board.GetLength(0) - 1 &&
                                        this.y + move_distance_right < this.chess_Board.GetLength(1) - 1)
                                {
                                    move_distance_down++;
                                    move_distance_right++;
                                    if (this.chess_Board[this.x + move_distance_down, this.y + move_distance_right] != null)
                                    {
                                        if (this.chess_Board[this.x + move_distance_down, this.y + move_distance_right].side == this.side)
                                        {
                                            move_distance_down--;
                                            move_distance_right--;
                                        }
                                        break;
                                    }
                                }
                                if (shift_x <= move_distance_down && shift_y <= move_distance_right) return true;
                            }

                            //анализ маршрута вниз влево от движемой фигуры
                            move_distance_down = 0;
                            move_distance_left = 0;
                            if (shift_x > 0 && shift_y < 0)
                            {
                                while (this.x + move_distance_down < this.chess_Board.GetLength(0) - 1 &&
                                        this.y + move_distance_left > 0)
                                {
                                    move_distance_down++;
                                    move_distance_left--;
                                    if (this.chess_Board[this.x + move_distance_down, this.y + move_distance_left] != null)
                                    {
                                        if (this.chess_Board[this.x + move_distance_down, this.y + move_distance_left].side == this.side)
                                        {
                                            move_distance_down--;
                                            move_distance_left++;
                                        }
                                        break;
                                    }
                                }
                                if (shift_x <= move_distance_down && shift_y >= move_distance_left) return true;
                            }

                            //анализ маршрута вверх влево от движемой фигуры
                            move_distance_up = 0;
                            move_distance_left = 0;
                            if (shift_x < 0 && shift_y < 0)
                            {
                                while (this.x + move_distance_up > 0 &&
                                        this.y + move_distance_left > 0)
                                {
                                    move_distance_up--;
                                    move_distance_left--;
                                    if (this.chess_Board[this.x + move_distance_up, this.y + move_distance_left] != null)
                                    {
                                        if (this.chess_Board[this.x + move_distance_up, this.y + move_distance_left].side == this.side)
                                        {
                                            move_distance_up++;
                                            move_distance_left++;
                                        }
                                        break;
                                    }
                                }
                                if (shift_x >= move_distance_up && shift_y >= move_distance_left) return true;
                            }

                            //анализ маршрута вверх вправо от движемой фигуры
                            move_distance_up = 0;
                            move_distance_right = 0;
                            if (shift_x < 0 && shift_y > 0)
                            {
                                while (this.x + move_distance_up > 0 &&
                                        this.y + move_distance_right < this.chess_Board.GetLength(1) - 1)
                                {
                                    move_distance_up--;
                                    move_distance_right++;
                                    if (this.chess_Board[this.x + move_distance_up, this.y + move_distance_right] != null)
                                    {
                                        if (this.chess_Board[this.x + move_distance_up, this.y + move_distance_right].side == this.side)
                                        {
                                            move_distance_up++;
                                            move_distance_right--;
                                        }
                                        break;
                                    }
                                }
                                if (shift_x >= move_distance_up && shift_y <= move_distance_right) return true;
                            } */

                    return false;
                }
            }

            function getCanvasPosition(chess, tPosition) {
                let x = tPosition.x * chess.size.width + chess.table.position.x;
                let y = tPosition.y * chess.size.height + chess.table.position.y;
                return new Vector(x, y);
            }

            function getCursorTablePosition(chess, cursorPos) {
                let x = Math.floor((cursorPos.x - chess.table.position.x) / chess.size.width);
                let y = Math.floor((cursorPos.y - chess.table.position.y) / chess.size.height);
                return new Vector(x, y);
            }

            //обновление состояния холста(анимация холста)
            function updateCanvas() {

                context.clearRect(0, 0, canvas.width, canvas.height)

                table.draw();
                if (table.update)
                    table.update();

                for (let i = 0; i < table.arrayOfChess.length; i++) {
                    //отрисовывает объект
                    table.arrayOfChess[i].draw();
                    //обновляет состояние объекта если внутри есть соответствующий метод
                    if (table.arrayOfChess[i].update)
                        table.arrayOfChess[i].update();
                }

                context.fillText("Player state: " + GameState, 20, 100);
                context.fillText("Side: " + PlayerSide, 20, 120);
                //context.fillText("MoveState: " + MoveState, 20, 140);

                requestAnimationFrame(updateCanvas);
            }

            let table = new Table();

            new Pawn(table, new Vector(3, 1), "White");
            new Pawn(table, new Vector(3, 2), "White");
            new Pawn(table, new Vector(3, 6), "Black");
            new Queen(table, new Vector(3, 4), "Black");

            canvas.addEventListener("mousedown", mouseDown);//////////////
            function mouseDown(event) {
                if (GameState === "WaitBegining") { }
                else if(GameState === "ActiveLeading"){

                    let targetObj;//захваченный объект
                    let mousePosInObj;//координаты курсора внутри объекта относительно его верхнего левого угла

                    //перебираем объекты из массива объектов-шахмат в объекте доски и выполняем ивент для шахматы на которую указывает курсор
                    for (let i = 0; i < table.arrayOfChess.length; i++) {
                        if (event.clientX > table.arrayOfChess[i].canvasPosition.x &&
                            event.clientX < table.arrayOfChess[i].canvasPosition.x + table.arrayOfChess[i].size.width &&
                            event.clientY > table.arrayOfChess[i].canvasPosition.y &&
                            event.clientY < table.arrayOfChess[i].canvasPosition.y + table.arrayOfChess[i].size.height) {

                            targetObj = table.arrayOfChess[i];
                            if (PlayerSide !== targetObj.side) break;

                            targetObj.oldCanvasPos.x = targetObj.canvasPosition.x;
                            targetObj.oldCanvasPos.y = targetObj.canvasPosition.y;

                            mousePosInObj = {
                                dx: event.clientX - targetObj.canvasPosition.x,
                                dy: event.clientY - targetObj.canvasPosition.y
                            };
                            canvas.addEventListener("mousemove", mouseMove);
                            canvas.addEventListener("mouseup", mouseUp);
                        }
                    }

                    function mouseMove(event) {
                        targetObj.canvasPosition.x = event.clientX - mousePosInObj.dx;
                        targetObj.canvasPosition.y = event.clientY - mousePosInObj.dy;
                        if (GameState === "ActiveWaiting") {
                            canvas.removeEventListener("mousemove", mouseMove);
                            canvas.removeEventListener("mouseup", mouseUp);
                            targetObj.canvasPosition.x = targetObj.oldCanvasPos.x;
                            targetObj.canvasPosition.y = targetObj.oldCanvasPos.y;
                        }
                    }

                    function mouseUp(event) {
                        canvas.removeEventListener("mousemove", mouseMove);
                        canvas.removeEventListener("mouseup", mouseUp);

                        //по текущим координатам захваченной фигуры определяем над какой ячейкой она находится
                        let tPos = getCursorTablePosition(targetObj, new Vector(event.clientX, event.clientY));
                        let cPos = getCanvasPosition(targetObj, tPos);//вычисляем координаты этой ячейки
                        let shift = {//смещение относительно изначального положения
                            dx: tPos.x - targetObj.tablePos.x,
                            dy: tPos.y - targetObj.tablePos.y
                        };

                        if (event.clientX > targetObj.oldCanvasPos.x && event.clientX < targetObj.oldCanvasPos.x + targetObj.size.width &&
                            event.clientY > targetObj.oldCanvasPos.y && event.clientY < targetObj.oldCanvasPos.y + targetObj.size.height) {
                            targetObj.canvasPosition.x = targetObj.oldCanvasPos.x;
                            targetObj.canvasPosition.y = targetObj.oldCanvasPos.y;
                        }
                        //если объект отпускают за пределами доски, то его возвращает в исходную позицию
                        else if (!(event.clientX > table.position.x && event.clientY > table.position.y &&
                            event.clientX < table.position.x + table.size.width && event.clientY < table.position.y + table.size.height)) {
                            targetObj.canvasPosition.x = targetObj.oldCanvasPos.x;
                            targetObj.canvasPosition.y = targetObj.oldCanvasPos.y;
                        }
                        //проверка на возможность сходить в данную клетку данной фигурой
                        else if (!targetObj.allowedShift(shift.dx, shift.dy)) {
                            targetObj.canvasPosition.x = targetObj.oldCanvasPos.x;
                            targetObj.canvasPosition.y = targetObj.oldCanvasPos.y;
                        }
                        //если в за мгновение до отпускания шахматы закончился ход
                        else if (GameState === "ActiveWaiting") {
                            targetObj.canvasPosition.x = targetObj.oldCanvasPos.x;
                            targetObj.canvasPosition.y = targetObj.oldCanvasPos.y;
                        }
                        //если объект можно вставить в данную ячейку, то удаляем из этой ячейки(через массив в объекте доски) объект фигуры и
                        //меняем координаты текущей фигуры на координаты этой ячейки
                        else {
                            let index = targetObj.table.arrayOfChess.findIndex(a => a.tablePos.x === tPos.x && a.tablePos.y === tPos.y);
                            targetObj.table.arrayOfChess[index] = null;
                            targetObj.table.arrayOfChess = targetObj.table.arrayOfChess.filter(a => a !== null);

                            targetObj.tablePos.x = tPos.x;
                            targetObj.tablePos.y = tPos.y;
                            targetObj.canvasPosition.x = cPos.x;
                            targetObj.canvasPosition.y = cPos.y;
                            targetObj.oldCanvasPos.x = targetObj.canvasPosition.x;
                            targetObj.oldCanvasPos.y = targetObj.canvasPosition.y;
                        }
                    }
                }
            }

            //WebPart------------------------------------------------------------

            let ip = "@ViewBag.Ip";
            let port = "@ViewBag.PORT";
            let socket = new WebSocket("ws://" + ip + ":" + port);


            let BSide = "Side:" + PlayerSide + "<delimiter>";////////
            let BPlayerState = "PlayerState:WaitBegining<delimiter>";
            let BIsCheckmate = "IsCheckmate:false<delimiter>";
            let BTableState = "TableState:" + buildChessPositions() + "<delimiter>";
            //let BMoveState = "MoveState:" + MoveState + "<delimiter>";

            let tempString = BSide + BPlayerState + BIsCheckmate + BTableState/* + BMoveState*/;
            let parsedResponse = parseResponse(tempString);
            let request = buildRequest(parsedResponse);

            socket.onopen = function (event) {
                socket.send(request + "\r\n\r\n");
            };
            socket.onmessage = function (event) {
                parsedResponse = parseResponse(event.data);
                //if (parsedResponse.get("MoveState") === "EndMove")
                //    MoveState = "CurrentMove";

                if (parsedResponse.get("PlayerState") === "ActiveLeading")
                    continueButton.disabled = false;
                else
                    continueButton.disabled = true;

                updateStates(parsedResponse);

                if (GameState === "ActiveWaiting")
                    updateChess(parsedResponse);
                if (GameState === "ActiveLeading")
                    parsedResponse.set("TableState", buildChessPositions());

                socket.send(buildRequest(parsedResponse) + "\r\n\r\n");
            };
            socket.onclose = function (event) {
                if (event.wasClean) {
                    alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
                }
                else {
                    // например, сервер убил процесс или сеть недоступна
                    // обычно в этом случае event.code 1006
                    alert('[close] Соединение прервано');
                }
            };
            socket.onerror = function (error) {
                alert(`[error] ${error.message}`);
            };


            function parseResponse(response) {
                let tempReq = response.split("<delimiter>");
                let dict = new Map();
                let temp1 = null;
                for (let i = 0; i < tempReq.length; i++) {
                    temp1 = tempReq[i].split(":");
                    dict.set(temp1[0], temp1[1]);
                }
                return dict;
            }

            function updateChess(parsedResponse) {
                let chessStrings = (parsedResponse.get("TableState")).split(";");
                if (chessStrings[0] === "" || chessStrings === undefined || chessStrings === null)
                    return;

                for (let i = 0; i < table.arrayOfChess.length; i++) {
                    let coordinates = chessStrings[i].match(/[0-9]+\.*[0-9]*/gi);
                    table.arrayOfChess[i].canvasPosition = new Vector(
                        coordinates[0],
                        coordinates[1]);
                }
            }

            function buildChessPositions() {
                let result = "";
                for (let i = 0; i < table.arrayOfChess.length; i++) {
                    let temp = table.arrayOfChess[i].canvasPosition;
                    if (i === table.arrayOfChess.length - 1)
                        result += "(" + temp.x.toString() + "," + temp.y.toString() + ")";
                    else
                        result += "(" + temp.x.toString() + "," + temp.y.toString() + ");";
                }
                return result;
            }

            function buildRequest(subRequests) {
                let result = "";
                result += "Side:" + subRequests.get("Side") + "<delimiter>";
                result += "PlayerState:" + subRequests.get("PlayerState") + "<delimiter>";
                result += "IsCheckmate:" + subRequests.get("IsCheckmate") + "<delimiter>";
                result += "TableState:" + subRequests.get("TableState") + "<delimiter>";
                //result += "MoveState:" + MoveState + "<delimiter>";
                return result;
            }

            function updateStates(parsedResponse) {
                GameState = parsedResponse.get("PlayerState");
                PlayerSide = parsedResponse.get("Side");
                //MoveState = parsedResponse.get("MoveState");
            }

            //--------------------------------------------------------------
            let continueButton = document.querySelector(".button1");
            continueButton.addEventListener("click", nextMove);
            async function nextMove() {
                let url = "http://" + document.location.host + "/Game/NextMove";
                let response = await fetch(url);

                if (response.ok) { // если HTTP-статус в диапазоне 200-299
                    let str = await response.text();
                } else {
                    alert("Ошибка HTTP: " + response.status);
                }
            }

            //--------------------------------------------------------------

            updateCanvas();
        }//присабачить кнопку конца хода с привязкой к состоянию, вместо таймера
    </script>
</body>
</html>
