
@{
    Layout = null;
}

<!DOCTYPE html>

<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <meta charset="utf-8">
    <title>GameSession</title>
</head>
<body>
    <canvas></canvas>
    <button class="button1">Continue</button>@*посылает запрос контроллеру на смену очереди хода*@
    <button class="button2">Surrender</button>@*посылает запрос контроллеру о том что игрок сдается*@

    <style>
        Canvas {
            position: absolute;
            z-index: -1;@*для вывода элементов html над холстом*@
            top: 0px;
            left: 0px;
        }
        .botton1{
            height: 50px;
            width: 100px;
        }
        .botton2{
            height: 50px;
            width: 100px;
            top: 60px;
        }
    </style>

    <script>
        {
            //States----------------------------------------------------------------------
            let GameStates = {
                WaitBegining: "WaitBegining",
                ActiveLeading: "ActiveLeading",
                ActiveWaiting: "ActiveWaiting",
                Winner: "Winner",
                Loser: "Loser",
                Disconnected: "Disconnected"
            }
            let PlayerSides = {
                Black: "Black",
                White: "White"
            }
            let GameState = GameStates.WaitBegining;
            let PlayerSide;

            //Definition of table and chess-----------------------------------------------
            let canvas = document.querySelector("canvas");
            let context = canvas.getContext("2d");
            context.font = "22px Verdana";
            canvas.width = innerWidth;
            canvas.height = innerHeight;

            class Vector {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                }

                Sum(addition) {
                    if (typeof (addition) === "number") {
                        let x = this.x + addition;
                        let y = this.y + addition;
                        return new Vector(x, y);
                    }
                    else if (typeof (addition) === "object") {
                        let x = this.x + addition.x;
                        let y = this.y + addition.y;
                        return new Vector(x, y);
                    }
                    else return undefined;
                }

                Multiply(multiplier) {
                    if (typeof (multiplier) === "number") {//произведение вектора на число
                        let x = this.x * multiplier;
                        let y = this.y * multiplier;
                        return new Vector(x, y);
                    }
                    else if (typeof (multiplier) === "object"/*!!!*/) {//скалярное произведение вектора на вектор через координаты
                        return this.x * multiplier.x + this.y * multiplier.y;
                    }
                    else return undefined;
                }
            }

            class Table {//шахматная доска
                constructor() {
                    //выставляем размеры игровой области относительно меньшей из длин экрана
                    if (innerHeight < innerWidth)
                        this.size = { width: innerHeight, height: innerHeight };
                    else
                        this.size = { width: innerWidth, height: innerWidth };

                    //координаты игровой области(ш/доски) в холсте
                    this.position = new Vector(canvas.width / 2 - this.size.width / 2, canvas.height / 2 - this.size.height / 2);

                    //словарь пар [id_шахматы:объект_шахматы]
                    this.dictOfChess = new Map();

                    this.img = new Image();
                    this.imgIsLoaded = false;
                    this.img.onload = () => {
                        this.imgIsLoaded = true;
                    }
                    this.img.src = "/ChessWeb/Chessboard.png";
                }

                draw() {
                    if (this.imgIsLoaded)//без этого может произойти попытка отрисовать еще не подгруженную картинку
                        context.drawImage(this.img, this.position.x, this.position.y, this.size.width, this.size.height);
                }

                update() { }/*!!!*/

                addChess(chess) {
                    for (let e of this.dictOfChess) {
                        if (e[1].id === chess.id) return;
                    }
                    this.dictOfChess.set(chess.id, chess);
                }
            }

            class Chess {
                constructor(table, tPosition, side, id) {
                    this.id = id;

                    this.table = table;
                    this.size = { width: table.size.width / 8, height: table.size.height / 8 };

                    //позиция фигуры внутри доски в клетках 
                    //(x,y) <==> (номер_клетки_по_горизонтали(слево направо),номер_клетки_по_вертикали(сверху вниз))
                    this.tablePos = new Vector(tPosition.x, tPosition.y);

                    //координаты в пикселях относительно левого верхнего угла холста
                    //старые координаты, нужные для возврата передвигаемой текущим игроком фигуры 
                    //в исходную позицию при неправильном ходе(см. обработчик события movedown)
                    this.oldCanvasPos = getCanvasPosition(this, tPosition);
                    //текущие координаты, нужные для вычисления позиции объектов фигур на холсте в данный момент времени
                    this.canvasPosition = getCanvasPosition(this, tPosition);

                    //пропорция координат фигуры относительно координат стола,
                    //нужная для обмена координатами между хостами игроков с разными размерами мониторов
                    this.relativeFromTablePosition = getRelativeFromTablePosition(this);

                    this.side = side;//White/Black

                    this.table.addChess(this);

                    this.img = new Image();
                    this.imgIsLoaded = false;
                    this.img.onload = () => {
                        this.imgIsLoaded = true;
                    }
                }

                draw() {
                    if (this.imgIsLoaded)//без этого может произойти попытка отрисовать еще не подгруженную картинку
                        context.drawImage(this.img, this.canvasPosition.x, this.canvasPosition.y, this.size.width, this.size.height);
                }

                update() { }/*!!!*/
            }

            class Pawn extends Chess {
                constructor(table, tPosition, side, id) {
                    super(table, tPosition, side, id);
                    if (side === "Black") {
                        this.img.src = "/ChessWeb/PeshkaB.png";
                    }
                    else {
                        this.img.src = "/ChessWeb/PeshkaW.png";
                    }
                }

                //высчитывает можно ли переместить текущий объект фигуры в координаты указанные через смещение,
                //где смещение(shift_x, shift_y) - число клеток по оси X и Y относительно текущего положени объекта(this.tablePos)
                allowedShift(shift_x, shift_y) {
                    if (shift_x === 0 && shift_y === 0)
                        return true;

                    //ходы в бок, либо вперед более чем на 1 клетку недопустимы
                    if ((Math.abs(shift_x) > 0 && shift_y === 0) || Math.abs(shift_y) > 1)
                        return false;
                    if (this.side === "White") {
                        if (shift_y < 0) return false;//белые расположены сверху и ходят только вниз
                    }
                    if (this.side === "Black") {
                        if (shift_y > 0) return false;//черные расположены снизу и ходят только вверх
                    }

                    //двинуться по диагонали если есть фигура и она враг
                    if (shift_x !== 0 && shift_y !== 0 &&
                        Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x + shift_x) && (a.tablePos.y === this.tablePos.y + shift_y))) {
                        if (Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x + shift_x) && (a.tablePos.y === this.tablePos.y + shift_y)).side !== this.side)
                            return true;
                        else
                            return false;
                    }
                    //двинуться вперед если никого нет
                    else if (shift_x === 0 && shift_y !== 0 &&
                        !(Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y + shift_y)))) {
                        return true;
                    }
                    return false;
                }
            }

            class Queen extends Chess {
                constructor(table, tPosition, side, id) {
                    super(table, tPosition, side, id);
                    if (side === "Black") {
                        this.img.src = "/ChessWeb/QueenB.png";
                    }
                    else {
                        this.img.src = "/ChessWeb/QueenW.png";
                    }
                }

                allowedShift(shift_x, shift_y) {
                    let tempChess;

                    //можно ходить по диагонали и по прямой 
                    if ((Math.abs(shift_x) !== Math.abs(shift_y)) && (shift_x !== 0 && shift_y !== 0))
                        return false;
                    if (shift_x === 0 && shift_y === 0)
                        return true;


                    //анализ маршрута вниз от движемой фигуры
                    let move_distance_down = 0;
                    if (shift_y > 0 && shift_x === 0) {
                        for (let i = this.tablePos.y; i < 8 && move_distance_down < Math.abs(shift_y); i++) {
                            move_distance_down++;
                            tempChess = Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y + move_distance_down));
                            if (tempChess) {
                                break;
                            }
                        }
                        //1)если на пути встретилась другая фигура и запрашиваемое смещение(shift_y) больше допустимого смещения(move_distance_down)(прыгнуть за другую фигуру) => false
                        //2)если на пути встретилась другая фигура и з/смещение равно д/смещению(прыгнуть на фигуру или перед ней)
                        // 2.1)на другую фигуру другого цвета => true
                        // 2.2)на другую фигуру своего цвета => false
                        // 2.3)на пустую клетку => true;
                        //3)если на пути нет других фигур(з/смещение всегда равно д/смещению) => true;
                        if (shift_y <= move_distance_down) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута вверх от движемой фигуры
                    let move_distance_up = 0;
                    if (shift_y < 0 && shift_x === 0) {
                        for (let i = this.tablePos.y; i > 0 && move_distance_up < Math.abs(shift_y); i--) {
                            move_distance_up++;
                            tempChess = Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y - move_distance_up));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (Math.abs(shift_y) <= move_distance_up) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута вправо от движемой фигуры
                    let move_distance_right = 0;
                    if (shift_x > 0 && shift_y == 0) {
                        for (let i = this.tablePos.x; i < 8 && move_distance_right < Math.abs(shift_x); i++) {
                            move_distance_right++;
                            tempChess = Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x + move_distance_right) && (a.tablePos.y === this.tablePos.y));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (shift_x <= move_distance_right) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута влево от движемой фигуры
                    let move_distance_left = 0;
                    if (shift_x < 0 && shift_y == 0) {
                        for (let i = this.tablePos.x; i > 0 && move_distance_left < Math.abs(shift_x); i--) {
                            move_distance_left++;
                            tempChess = Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x - move_distance_left) && (a.tablePos.y === this.tablePos.y));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (Math.abs(shift_x) <= move_distance_left) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута вниз вправо от движемой фигуры
                    move_distance_right = 0;
                    move_distance_down = 0;
                    if (shift_x > 0 && shift_y > 0) {
                        let i = this.tablePos.x;
                        let j = this.tablePos.y;
                        while (i < 8 && move_distance_right < Math.abs(shift_x) && j < 8 && move_distance_down < Math.abs(shift_y)) {
                            i++; j++;
                            move_distance_down++;
                            move_distance_right++;
                            tempChess = Array.from(this.table.dictOfChess.values())
                                .find(a => (a.tablePos.x === this.tablePos.x + move_distance_right) && (a.tablePos.y === this.tablePos.y + move_distance_down));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (shift_x <= move_distance_right && shift_y <= move_distance_down) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута вниз влево от движемой фигуры
                    move_distance_left = 0;
                    move_distance_down = 0;
                    if (shift_x < 0 && shift_y > 0) {
                        let i = this.tablePos.x;
                        let j = this.tablePos.y;
                        while (i > 0 && move_distance_left < Math.abs(shift_x) && j < 8 && move_distance_down < Math.abs(shift_y)) {
                            i--; j++;
                            move_distance_down++;
                            move_distance_left++;
                            tempChess = Array.from(this.table.dictOfChess.values())
                                .find(a => (a.tablePos.x === this.tablePos.x - move_distance_left) && (a.tablePos.y === this.tablePos.y + move_distance_down));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (Math.abs(shift_x) <= move_distance_left && shift_y <= move_distance_down) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута вверх влево от движемой фигуры
                    move_distance_left = 0;
                    move_distance_up = 0;
                    if (shift_x < 0 && shift_y < 0) {
                        let i = this.tablePos.x;
                        let j = this.tablePos.y;
                        while (i > 0 && move_distance_left < Math.abs(shift_x) && j > 0 && move_distance_up < Math.abs(shift_y)) {
                            i--; j--;
                            move_distance_up++;
                            move_distance_left++;
                            tempChess = Array.from(this.table.dictOfChess.values())
                                .find(a => (a.tablePos.x === this.tablePos.x - move_distance_left) && (a.tablePos.y === this.tablePos.y - move_distance_up));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (Math.abs(shift_x) <= move_distance_left && Math.abs(shift_y) <= move_distance_up) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута вверх вправо от движемой фигуры
                    move_distance_right = 0;
                    move_distance_up = 0;
                    if (shift_x > 0 && shift_y < 0) {
                        let i = this.tablePos.x;
                        let j = this.tablePos.y;
                        while (i < 8 && move_distance_right < Math.abs(shift_x) && j > 0 && move_distance_up < Math.abs(shift_y)) {
                            i++; j--;
                            move_distance_up++;
                            move_distance_right++;
                            tempChess = Array.from(this.table.dictOfChess.values())
                                .find(a => (a.tablePos.x === this.tablePos.x + move_distance_right) && (a.tablePos.y === this.tablePos.y - move_distance_up));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (shift_x <= move_distance_right && Math.abs(shift_y) <= move_distance_up) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    return false;
                }
            }

            class King extends Chess {
                constructor(table, tPosition, side, id) {
                    super(table, tPosition, side, id);
                    if (side === "Black") {
                        this.img.src = "/ChessWeb/KingB.png";
                    }
                    else {
                        this.img.src = "/ChessWeb/KingW.png";
                    }
                }

                allowedShift(shift_x, shift_y) {
                    let tempChess;

                    if (shift_x === 0 && shift_y === 0)
                        return true;

                    if (((shift_x <= 1 && shift_x >= -1) && (shift_y <= 1 && shift_y >= -1))) {
                        tempChess = Array.from(this.table.dictOfChess.values())
                            .find(a => (a.tablePos.x === this.tablePos.x + shift_x) && (a.tablePos.y === this.tablePos.y + shift_y));

                        if (!tempChess)
                            return true;
                        else if (tempChess.side != this.side)
                            return true;
                    }

                    return false;
                }
            }

            class Knight extends Chess {
                constructor(table, tPosition, side, id) {
                    super(table, tPosition, side, id);
                    if (side === "Black") {
                        this.img.src = "/ChessWeb/KnightB.png";
                    }
                    else {
                        this.img.src = "/ChessWeb/KnightW.png";
                    }
                }

                allowedShift(shift_x, shift_y) {
                    let tempChess;

                    if (shift_x == 0 && shift_y == 0)
                        return true;

                    //если ход (2 вверх или вниз и 1 налево или направо) или (2 налево или направло и 1 вверх или вниз)
                    if (((shift_x === 2 || shift_x === -2) && (shift_y === 1 || shift_y === -1)) || ((shift_x === 1 || shift_x === -1) && (shift_y === 2 || shift_y === -2))) {
                        tempChess = Array.from(this.table.dictOfChess.values())
                            .find(a => (a.tablePos.x === this.tablePos.x + shift_x) && (a.tablePos.y === this.tablePos.y + shift_y));

                        if (!tempChess)
                            return true;
                        else if (tempChess.side !== this.side)
                            return true;
                    }

                    return false;
                }
            }

            class Castle extends Chess {
                constructor(table, tPosition, side, id) {
                    super(table, tPosition, side, id);
                    if (side === "Black") {
                        this.img.src = "/ChessWeb/CastleB.png";
                    }
                    else {
                        this.img.src = "/ChessWeb/CastleW.png";
                    }
                }

                allowedShift(shift_x, shift_y) {
                    let tempChess;

                    //можно ходить по прямой
                    if (shift_x != 0 && shift_y != 0)
                        return false;
                    if (shift_x == 0 && shift_y == 0)
                        return true;

                    //анализ маршрута вниз от движемой фигуры
                    let move_distance_down = 0;
                    if (shift_y > 0 && shift_x === 0) {
                        for (let i = this.tablePos.y; i < 8 && move_distance_down < Math.abs(shift_y); i++) {
                            move_distance_down++;
                            tempChess = Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y + move_distance_down));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (shift_y <= move_distance_down) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута вверх от движемой фигуры
                    let move_distance_up = 0;
                    if (shift_y < 0 && shift_x === 0) {
                        for (let i = this.tablePos.y; i > 0 && move_distance_up < Math.abs(shift_y); i--) {
                            move_distance_up++;
                            tempChess = Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y - move_distance_up));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (Math.abs(shift_y) <= move_distance_up) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута вправо от движемой фигуры
                    let move_distance_right = 0;
                    if (shift_x > 0 && shift_y == 0) {
                        for (let i = this.tablePos.x; i < 8 && move_distance_right < Math.abs(shift_x); i++) {
                            move_distance_right++;
                            tempChess = Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x + move_distance_right) && (a.tablePos.y === this.tablePos.y));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (shift_x <= move_distance_right) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута влево от движемой фигуры
                    let move_distance_left = 0;
                    if (shift_x < 0 && shift_y == 0) {
                        for (let i = this.tablePos.x; i > 0 && move_distance_left < Math.abs(shift_x); i--) {
                            move_distance_left++;
                            tempChess = Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x - move_distance_left) && (a.tablePos.y === this.tablePos.y));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (Math.abs(shift_x) <= move_distance_left) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    return false;
                }
            }

            class Bishop extends Chess {
                constructor(table, tPosition, side, id) {
                    super(table, tPosition, side, id);
                    if (side === "Black") {
                        this.img.src = "/ChessWeb/BishopB.png";
                    }
                    else {
                        this.img.src = "/ChessWeb/BishopW.png";
                    }
                }

                allowedShift(shift_x, shift_y) {
                    let tempChess;

                    //можно ходить только по диагонали
                    if (Math.abs(shift_x) != Math.abs(shift_y))
                        return false;
                    if (shift_x == 0 && shift_y == 0)
                        return true;

                    //анализ маршрута вниз вправо от движемой фигуры
                    let move_distance_right = 0;
                    let move_distance_down = 0;
                    if (shift_x > 0 && shift_y > 0) {
                        let i = this.tablePos.x;
                        let j = this.tablePos.y;
                        while (i < 8 && move_distance_right < Math.abs(shift_x) && j < 8 && move_distance_down < Math.abs(shift_y)) {
                            i++; j++;
                            move_distance_down++;
                            move_distance_right++;
                            tempChess = Array.from(this.table.dictOfChess.values())
                                .find(a => (a.tablePos.x === this.tablePos.x + move_distance_right) && (a.tablePos.y === this.tablePos.y + move_distance_down));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (shift_x <= move_distance_right && shift_y <= move_distance_down) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута вниз влево от движемой фигуры
                    let move_distance_left = 0;
                    move_distance_down = 0;
                    if (shift_x < 0 && shift_y > 0) {
                        let i = this.tablePos.x;
                        let j = this.tablePos.y;
                        while (i > 0 && move_distance_left < Math.abs(shift_x) && j < 8 && move_distance_down < Math.abs(shift_y)) {
                            i--; j++;
                            move_distance_down++;
                            move_distance_left++;
                            tempChess = Array.from(this.table.dictOfChess.values())
                                .find(a => (a.tablePos.x === this.tablePos.x - move_distance_left) && (a.tablePos.y === this.tablePos.y + move_distance_down));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (Math.abs(shift_x) <= move_distance_left && shift_y <= move_distance_down) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута вверх влево от движемой фигуры
                    move_distance_left = 0;
                    let move_distance_up = 0;
                    if (shift_x < 0 && shift_y < 0) {
                        let i = this.tablePos.x;
                        let j = this.tablePos.y;
                        while (i > 0 && move_distance_left < Math.abs(shift_x) && j > 0 && move_distance_up < Math.abs(shift_y)) {
                            i--; j--;
                            move_distance_up++;
                            move_distance_left++;
                            tempChess = Array.from(this.table.dictOfChess.values())
                                .find(a => (a.tablePos.x === this.tablePos.x - move_distance_left) && (a.tablePos.y === this.tablePos.y - move_distance_up));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (Math.abs(shift_x) <= move_distance_left && Math.abs(shift_y) <= move_distance_up) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    //анализ маршрута вверх вправо от движемой фигуры
                    move_distance_right = 0;
                    move_distance_up = 0;
                    if (shift_x > 0 && shift_y < 0) {
                        let i = this.tablePos.x;
                        let j = this.tablePos.y;
                        while (i < 8 && move_distance_right < Math.abs(shift_x) && j > 0 && move_distance_up < Math.abs(shift_y)) {
                            i++; j--;
                            move_distance_up++;
                            move_distance_right++;
                            tempChess = Array.from(this.table.dictOfChess.values())
                                .find(a => (a.tablePos.x === this.tablePos.x + move_distance_right) && (a.tablePos.y === this.tablePos.y - move_distance_up));
                            if (tempChess) {
                                break;
                            }
                        }
                        if (shift_x <= move_distance_right && Math.abs(shift_y) <= move_distance_up) {
                            if (!tempChess) return true;
                            if (tempChess.side !== this.side) return true;
                        }
                    }

                    return false;
                }
            }

            function getRelativeFromTablePosition(chess) {/*!!!*/
                let relativeX = (chess.canvasPosition.x - chess.table.position.x) / chess.table.size.width;
                let relativeY = (chess.canvasPosition.y - chess.table.position.y) / chess.table.size.height;
                return new Vector(relativeX, relativeY);
            }

            function getCanvasPosition(chess, tPosition) {/*!!!*/
                let x = tPosition.x * chess.size.width + chess.table.position.x;
                let y = tPosition.y * chess.size.height + chess.table.position.y;
                return new Vector(x, y);
            }

            function getCursorTablePosition(chess, cursorPos) {/*!!!*/
                let x = Math.floor((cursorPos.x - chess.table.position.x) / chess.size.width);
                let y = Math.floor((cursorPos.y - chess.table.position.y) / chess.size.height);
                return new Vector(x, y);
            }

            //объект доски
            let table = new Table();

            //объекты шахмат
            {
                //короли должны занимать 0 и 1 id, по которым будет вычисляться живы ли они
                new King(table, new Vector(3, 0), "White", 0);
                new King(table, new Vector(3, 7), "Black", 1);

                new Pawn(table, new Vector(0, 1), "White", 2);
                new Pawn(table, new Vector(1, 1), "White", 3);
                new Pawn(table, new Vector(2, 1), "White", 4);
                new Pawn(table, new Vector(3, 1), "White", 5);
                new Pawn(table, new Vector(4, 1), "White", 6);
                new Pawn(table, new Vector(5, 1), "White", 7);
                new Pawn(table, new Vector(6, 1), "White", 8);
                new Pawn(table, new Vector(7, 1), "White", 9);

                new Castle(table, new Vector(0, 0), "White", 10);
                new Knight(table, new Vector(1, 0), "White", 11);
                new Bishop(table, new Vector(2, 0), "White", 12);
                new Queen(table, new Vector(4, 0), "White", 13);
                new Bishop(table, new Vector(5, 0), "White", 14);
                new Knight(table, new Vector(6, 0), "White", 15);
                new Castle(table, new Vector(7, 0), "White", 16);

                new Pawn(table, new Vector(0, 6), "Black", 17);
                new Pawn(table, new Vector(1, 6), "Black", 18);
                new Pawn(table, new Vector(2, 6), "Black", 19);
                new Pawn(table, new Vector(3, 6), "Black", 20);
                new Pawn(table, new Vector(4, 6), "Black", 21);
                new Pawn(table, new Vector(5, 6), "Black", 22);
                new Pawn(table, new Vector(6, 6), "Black", 23);
                new Pawn(table, new Vector(7, 6), "Black", 24);

                new Castle(table, new Vector(0, 7), "Black", 25);
                new Knight(table, new Vector(1, 7), "Black", 26);
                new Bishop(table, new Vector(2, 7), "Black", 27);
                new Queen(table, new Vector(4, 7), "Black", 28);
                new Bishop(table, new Vector(5, 7), "Black", 29);
                new Knight(table, new Vector(6, 7), "Black", 30);
                new Castle(table, new Vector(7, 7), "Black", 31);
            }

            let moveCount = 0;//нужно чтобы игрок мог сходить 1 раз за текущий ход
            let IsKingDead = false;//нужно чтобы отключить кнопку следующего хода(см. обработчик событий кнопки continueButton)
            function mouseDown(event) {
                if (GameState === "ActiveLeading" && moveCount === 0) {
                    let targetObj;//захваченный(целевой) объект
                    let mousePosInObj;//координаты курсора внутри объекта-фигуры относительно его верхнего левого угла

                    //перебираем фигуры в коллекции объектов-фигур в объекте доски и 
                    //выполняем ивент для шахматы на которую указывает курсор
                    for (let pairIdChess of table.dictOfChess) {
                        if (event.clientX > pairIdChess[1].canvasPosition.x &&
                            event.clientX < pairIdChess[1].canvasPosition.x + pairIdChess[1].size.width &&
                            event.clientY > pairIdChess[1].canvasPosition.y &&
                            event.clientY < pairIdChess[1].canvasPosition.y + pairIdChess[1].size.height) {

                            targetObj = pairIdChess[1];
                            if (PlayerSide !== targetObj.side) break;//можно перетаскивать только фигуры своего цвета

                            //запоминаем где стояла фигура, которую сейчас будут перемещать
                            targetObj.oldCanvasPos.x = targetObj.canvasPosition.x;
                            targetObj.oldCanvasPos.y = targetObj.canvasPosition.y;

                            mousePosInObj = {
                                dx: event.clientX - targetObj.canvasPosition.x,
                                dy: event.clientY - targetObj.canvasPosition.y
                            };

                            canvas.addEventListener("mousemove", mouseMove);
                            canvas.addEventListener("mouseup", mouseUp);
                        }
                    }

                    function mouseMove(event) {
                        //получаем относительные координаты для передачи их ожидающему игроку
                        targetObj.relativeFromTablePosition.x = (event.clientX - table.position.x - mousePosInObj.dx) / targetObj.table.size.width;
                        targetObj.relativeFromTablePosition.y = (event.clientY - table.position.y - mousePosInObj.dy) / targetObj.table.size.height;

                        //по относительным получаем абсолютные текущие координаты
                        targetObj.canvasPosition.x = targetObj.table.position.x + targetObj.relativeFromTablePosition.x * table.size.width;
                        targetObj.canvasPosition.y = targetObj.table.position.y + targetObj.relativeFromTablePosition.y * table.size.height;

                        if (GameState === "ActiveWaiting") {//на всякий случай
                            canvas.removeEventListener("mousemove", mouseMove);
                            canvas.removeEventListener("mouseup", mouseUp);

                            targetObj.relativeFromTablePosition.x = (targetObj.oldCanvasPos.x - table.position.x) / table.size.width;
                            targetObj.relativeFromTablePosition.y = (targetObj.oldCanvasPos.y - table.position.y) / table.size.height;

                            targetObj.canvasPosition.x = table.position.x + targetObj.relativeFromTablePosition.x * table.size.width;
                            targetObj.canvasPosition.y = table.position.y + targetObj.relativeFromTablePosition.y * table.size.height;
                        }
                    }

                    function mouseUp(event) {
                        canvas.removeEventListener("mousemove", mouseMove);
                        canvas.removeEventListener("mouseup", mouseUp);

                        //по текущим координатам захваченной фигуры определяем над какой ячейкой она находится
                        let tPos = getCursorTablePosition(targetObj, new Vector(event.clientX, event.clientY));
                        let cPos = getCanvasPosition(targetObj, tPos);//вычисляем координаты этой ячейки
                        let shift = {//смещение относительно изначального положения(в клетках)
                            dx: tPos.x - targetObj.tablePos.x,
                            dy: tPos.y - targetObj.tablePos.y
                        };

                        //если объект отпускают в исходной клетке, то его возвращает в исходную позицию
                        if (event.clientX > targetObj.oldCanvasPos.x && event.clientX < targetObj.oldCanvasPos.x + targetObj.size.width &&
                            event.clientY > targetObj.oldCanvasPos.y && event.clientY < targetObj.oldCanvasPos.y + targetObj.size.height) {
                            targetObj.relativeFromTablePosition.x = (targetObj.oldCanvasPos.x - table.position.x) / table.size.width;
                            targetObj.relativeFromTablePosition.y = (targetObj.oldCanvasPos.y - table.position.y) / table.size.height;

                            targetObj.canvasPosition.x = table.position.x + targetObj.relativeFromTablePosition.x * table.size.width;
                            targetObj.canvasPosition.y = table.position.y + targetObj.relativeFromTablePosition.y * table.size.height;
                        }
                        //если объект отпускают за пределами доски, то его возвращает в исходную позицию
                        else if (!(event.clientX > table.position.x && event.clientY > table.position.y &&
                            event.clientX < table.position.x + table.size.width && event.clientY < table.position.y + table.size.height)) {
                            targetObj.relativeFromTablePosition.x = (targetObj.oldCanvasPos.x - table.position.x) / table.size.width;
                            targetObj.relativeFromTablePosition.y = (targetObj.oldCanvasPos.y - table.position.y) / table.size.height;

                            targetObj.canvasPosition.x = table.position.x + targetObj.relativeFromTablePosition.x * table.size.width;
                            targetObj.canvasPosition.y = table.position.y + targetObj.relativeFromTablePosition.y * table.size.height;
                        }
                        //проверка на возможность сходить в данную клетку данной фигурой
                        else if (!targetObj.allowedShift(shift.dx, shift.dy)) {
                            targetObj.relativeFromTablePosition.x = (targetObj.oldCanvasPos.x - table.position.x) / table.size.width;
                            targetObj.relativeFromTablePosition.y = (targetObj.oldCanvasPos.y - table.position.y) / table.size.height;

                            targetObj.canvasPosition.x = table.position.x + targetObj.relativeFromTablePosition.x * table.size.width;
                            targetObj.canvasPosition.y = table.position.y + targetObj.relativeFromTablePosition.y * table.size.height;
                        }
                        //если за мгновение до отпускания шахматы закончился ход(опять на всякий случай)
                        else if (GameState === "ActiveWaiting") {
                            targetObj.relativeFromTablePosition.x = (targetObj.oldCanvasPos.x - table.position.x) / table.size.width;
                            targetObj.relativeFromTablePosition.y = (targetObj.oldCanvasPos.y - table.position.y) / table.size.height;

                            targetObj.canvasPosition.x = table.position.x + targetObj.relativeFromTablePosition.x * table.size.width;
                            targetObj.canvasPosition.y = table.position.y + targetObj.relativeFromTablePosition.y * table.size.height;
                        }
                        //если объект можно вставить в данную ячейку, то удаляем из этой ячейки(через словарь в объекте доски) объект фигуры и
                        //меняем координаты текущей фигуры на координаты этой ячейки
                        else {
                            let idOfChessToDelete;
                            for (let pairIdChess of table.dictOfChess) {
                                if (pairIdChess[1].tablePos.x === tPos.x && pairIdChess[1].tablePos.y === tPos.y) {
                                    if (pairIdChess[0] === 0 || pairIdChess[0] === 1) {
                                        IsKingDead = true;
                                    }
                                    idOfChessToDelete = pairIdChess[0];
                                    table.dictOfChess.delete(idOfChessToDelete);
                                    break;
                                }
                            }

                            targetObj.tablePos.x = tPos.x;
                            targetObj.tablePos.y = tPos.y;
                            targetObj.canvasPosition.x = cPos.x;
                            targetObj.canvasPosition.y = cPos.y;
                            targetObj.oldCanvasPos.x = targetObj.canvasPosition.x;
                            targetObj.oldCanvasPos.y = targetObj.canvasPosition.y;

                            targetObj.relativeFromTablePosition = getRelativeFromTablePosition(targetObj);

                            moveCount++;
                        }
                    }
                }
            }
            canvas.addEventListener("mousedown", mouseDown);//позволяет двигать объекты шахмат

            //Animation------------------------------------------------------------------
            function updateCanvas() {
                context.clearRect(0, 0, canvas.width, canvas.height)

                table.draw();
                if (table.update)
                    table.update();

                for (let pairIdChess of table.dictOfChess) {/*!!!*/
                    //отрисовывает объект
                    pairIdChess[1].draw();
                    //обновляет состояние объекта если внутри есть соответствующий метод
                    if (pairIdChess[1].update)
                        pairIdChess[1].update();
                }

                //TESTS
                context.fillText("Player state: " + GameState, 20, 140);
                context.fillText("Side: " + PlayerSide, 20, 150);
                //context.fillText("Response: " + parsedResponse.get("TableState").toString(), 20, 160);
                //if (table.dictOfChess.has(1)) {
                //    context.fillText("Pawn1: " + table.dictOfChess.get(1).relativeFromTablePosition.x +
                //        " " + table.dictOfChess.get(1).relativeFromTablePosition.y, 20, 150);
                //    context.fillText("Pawn1: " + table.dictOfChess.get(1).oldCanvasPos.x +
                //        " " + table.dictOfChess.get(1).oldCanvasPos.y, 20, 160);
                //    context.fillText("Pawn1: " + table.dictOfChess.get(1).canvasPosition.x +
                //        " " + table.dictOfChess.get(1).canvasPosition.y, 20, 170);
                //}
                //if (table.dictOfChess.has(3)) {
                //    context.fillText("Queen1: " + table.dictOfChess.get(3).relativeFromTablePosition.x +
                //        " " + table.dictOfChess.get(3).relativeFromTablePosition.y, 20, 190);
                //    context.fillText("Queen1: " + table.dictOfChess.get(3).oldCanvasPos.x +
                //        " " + table.dictOfChess.get(3).oldCanvasPos.y, 20, 200);
                //    context.fillText("Queen1: " + table.dictOfChess.get(3).canvasPosition.x +
                //        " " + table.dictOfChess.get(3).canvasPosition.y, 20, 210);
                //}

                requestAnimationFrame(updateCanvas);
            }

            //WebSoсket logic------------------------------------------------------------
            //адрес сервера сессии
            let ip = "@ViewBag.Ip";
            let port = "@ViewBag.PORT";
            let sessionId = @ViewBag.sessionId;
            let playerNumber = @ViewBag.playerNumber;
            let socket = new WebSocket("ws://" + ip + ":" + port);

            //для отправки серверу по первому запросу(после рукопожатия)
            let BSide = "Side:" + PlayerSide + "<delimiter>";
            let BPlayerState = "PlayerState:WaitBegining<delimiter>";
            let BIsCheckmate = "IsCheckmate:false<delimiter>";
            let BTableState = "TableState:" + buildChessPositions() + "<delimiter>";
            let PlayerNumber = "PlayerNumber:" + playerNumber + "<delimiter>";
            let SessionId = "SessionId:" + sessionId + "<delimiter>";
            let IsConnectedQuery = "IsConnectedQuery:true<delimiter>";

            let tempString = BSide + BPlayerState + BIsCheckmate + BTableState + PlayerNumber + SessionId + IsConnectedQuery;
            let parsedResponse = parseResponse(tempString);
            let request = buildRequest(parsedResponse);

            socket.onopen = function (event) {//первый запрос по вебсокету от клиента
                socket.send(request + "\r\n\r\n");
            };
            socket.onmessage = function (event) {//цикл обмена данными(состояниями игроков/сессии и относительными координатами) с сервером
                parsedResponse = parseResponse(event.data);

                //получаем цвет(при первом запросе, дальше он не меняется) и игровое состояние
                updateStates(parsedResponse);

                //пока игрок ждет своей очереди, он не может продолжить ход
                if (GameState === "ActiveLeading")
                    continueButton.disabled = false;
                else
                    continueButton.disabled = true;

                //ждущий своего хода игрок получает состояние объектов-фигур от активного игрока через сервер
                if (GameState === "ActiveWaiting") {
                    moveCount = 0;
                    updateChess(parsedResponse);

                    //если короля ждущего игрока убивают, то он автоматически сдается
                    /*!!!*/
                    let t1 = table.dictOfChess.get(0);
                    let t2 = table.dictOfChess.get(1);
                    if ((PlayerSide === "White" && !t1) || (PlayerSide === "Black" && !t2)) {
                        IsKingDead = true;
                        surrender();
                    }
                }
                //активный игрок отправляет состояние своего стола ждущему через сервер
                if (GameState === "ActiveLeading")
                    parsedResponse.set("TableState", buildChessPositions());
                //определение победителя происходит при отправке на контроллер запроса о том что игрок сдался
                //(см.метод surrender и одноименный контроллер)
                if (GameState === "Loser") {
                    alert("You lose, gg");
                    socket.close();
                }
                if (GameState === "Winner") {
                    alert("You win, graz");
                    socket.close();
                }
                //если один игрок вышел из игры выключив страницу/браузер, либо попытался создать новую сессию перезайдя в игру,
                //то текущая сессия прерывается(см. на сервере метод FinalizeSession() и обработчик запросов по веб сокету)
                if (GameState === "Disconnected") {
                    alert("You opponent disconnected");
                    socket.close();
                }

                socket.send(buildRequest(parsedResponse) + "\r\n\r\n");
            };
            socket.onclose = function (event) {
                if (event.wasClean) {
                    alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
                }
                else {
                    // например, сервер убил процесс или сеть недоступна
                    // обычно в этом случае event.code 1006
                    alert('[close] Соединение прервано');
                }
            };
            socket.onerror = function (error) {
                alert(`[error] ${error.message}`);
            };

            function parseResponse(response) {
                //Header1:blabla1<delimiter>Header2:blabla2<delimiter>...<delimiter> -> (Header1:blabla1)(Header2:blabla2)...
                let tempReq = response.split("<delimiter>");
                tempReq = tempReq.slice(0, tempReq.length - 1);
                let dict = new Map();
                let temp1 = null;
                for (let i = 0; i < tempReq.length; i++) {
                    temp1 = tempReq[i].split(":");
                    dict.set(temp1[0], temp1[1]);
                }
                return dict;
            }

            function updateChess(parsedResponse) {
                let chessStrings = (parsedResponse.get("TableState")).split(";");
                chessStrings.splice(chessStrings.length - 1, 1);

                let dictIdChessRelCoord = new Map();//(id: {relX, relY})
                for (let e of chessStrings) {
                    let IdXY = e.match(/[0-9]+\.*[0-9]*/gi);
                    dictIdChessRelCoord.set(Number(IdXY[0]), {
                        relX: Number(IdXY[1]),
                        relY: Number(IdXY[2])
                    });
                }

                for (let pairIdChess of table.dictOfChess) {
                    if (!dictIdChessRelCoord.has(pairIdChess[0])) {
                        table.dictOfChess.delete(pairIdChess[0]);
                    }
                    else {
                        pairIdChess[1].relativeFromTablePosition.x = dictIdChessRelCoord.get(pairIdChess[0]).relX;
                        pairIdChess[1].relativeFromTablePosition.y = dictIdChessRelCoord.get(pairIdChess[0]).relY;

                        pairIdChess[1].canvasPosition.x = pairIdChess[1].table.position.x + pairIdChess[1].relativeFromTablePosition.x * pairIdChess[1].table.size.width;
                        pairIdChess[1].canvasPosition.y = pairIdChess[1].table.position.y + pairIdChess[1].relativeFromTablePosition.y * pairIdChess[1].table.size.height;

                        pairIdChess[1].oldCanvasPos.x = pairIdChess[1].canvasPosition.x;
                        pairIdChess[1].oldCanvasPos.y = pairIdChess[1].canvasPosition.y;

                        pairIdChess[1].tablePos.x = Math.floor((pairIdChess[1].canvasPosition.x - pairIdChess[1].table.position.x) / pairIdChess[1].size.width);
                        pairIdChess[1].tablePos.y = Math.floor((pairIdChess[1].canvasPosition.y - pairIdChess[1].table.position.y) / pairIdChess[1].size.height);
                    }
                }
            }

            function buildChessPositions() {
                let result = "";
                for (let pairIdChess of table.dictOfChess) {
                    let relCoordinates = pairIdChess[1].relativeFromTablePosition;
                    result += "(" + pairIdChess[0] + "," + relCoordinates.x.toString() + "," + relCoordinates.y.toString() + ");";
                }
                return result;
            }

            function buildRequest(subRequests) {
                let result = "";
                for (let key of subRequests.keys()) {
                    result += key + ":" + subRequests.get(key) + "<delimiter>";
                }

                return result;
            }

            function updateStates(parsedResponse) {
                GameState = parsedResponse.get("PlayerState");
                PlayerSide = parsedResponse.get("Side");
            }

            //Click button to continue--------------------------------------
            let continueButton = document.querySelector(".button1");
            continueButton.addEventListener("click", nextMove);
            async function nextMove() {
                if (IsKingDead) return;
                let url = "http://" + document.location.host + "/Game/NextMove";
                let response = await fetch(url);

                if (response.ok) { // если HTTP-статус в диапазоне 200-299
                    let str = await response.text();
                } else {
                    alert("Ошибка HTTP: " + response.status);
                }
            }

            //Click button to surrender--------------------------------------
            let surrenderButton = document.querySelector(".button2");
            surrenderButton.addEventListener("click", surrender);
            async function surrender() {
                let url = "http://" + document.location.host + "/Game/Surrender";
                let response = await fetch(url);

                if (response.ok) { // если HTTP-статус в диапазоне 200-299
                    let str = await response.text();
                } else {
                    alert("Ошибка HTTP: " + response.status);
                }
            }

            window.onclose = function () { socket.close(); }
            window.onunload = function () { socket.close(); }

            //--------------------------------------------------------------
            updateCanvas();
        }
    </script>
</body>
</html>
