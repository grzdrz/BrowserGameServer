
@{
    Layout = null;
}

<!DOCTYPE html>

<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <meta charset="utf-8">
    <title>GameSession</title>
</head>
<body>
    <canvas></canvas>
    <button class="button1">Continue</button>@*посылает запрос контроллеру на смену очереди хода*@
    <button class="button2">Surrender</button>@*посылает запрос контроллеру о том что игрок сдается*@

    <style>
        Canvas {
            position: absolute;
            z-index: -1;@*для вывода элементов html над холстом*@
            top: 0px;
            left: 0px;
        }
        .botton1{
            height: 50px;
            width: 100px;
        }
        .botton2{
            height: 50px;
            width: 100px;
            top: 60px;
        }
    </style>

    <script>
        {
            //States----------------------------------------------------------------------
            let GameStates = {
                WaitBegining: "WaitBegining",
                ActiveLeading: "ActiveLeading",
                ActiveWaiting: "ActiveWaiting",
                Winner: "Winner",
                Loser: "Loser",
                Disconnected: "Disconnected"
            }
            let PlayerSides = {
                Black: "Black",
                White: "White"
            }
            let GameState = GameStates.WaitBegining;
            let PlayerSide;

            //Definition of table and chess-----------------------------------------------
            let canvas = document.querySelector("canvas");
            let context = canvas.getContext("2d");
            context.font = "22px Verdana";
            canvas.width = innerWidth;
            canvas.height = innerHeight;

            class Vector {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                }

                Sum(addition) {
                    if (typeof (addition) === "number") {
                        let x = this.x + addition;
                        let y = this.y + addition;
                        return new Vector(x, y);
                    }
                    else if (typeof (addition) === "object") {
                        let x = this.x + addition.x;
                        let y = this.y + addition.y;
                        return new Vector(x, y);
                    }
                    else return undefined;
                }

                Multiply(multiplier) {
                    if (typeof (multiplier) === "number") {
                        let x = this.x * multiplier;
                        let y = this.y * multiplier;
                        return new Vector(x, y);
                    }
                    else if (typeof (multiplier) === "object") {
                        return this.x * multiplier.x + this.y * multiplier.y;
                    }
                    else return undefined;
                }
            }

            class Table {
                constructor() {
                    if (innerHeight < innerWidth)
                        this.size = { width: innerHeight, height: innerHeight };
                    else
                        this.size = { width: innerWidth, height: innerWidth };

                    this.position = new Vector(canvas.width / 2 - this.size.width / 2, canvas.height / 2 - this.size.height / 2);

                    this.dictOfChess = new Map();

                    this.img = new Image();
                    this.imgIsLoaded = false;
                    this.img.onload = () => {
                        this.imgIsLoaded = true;
                    }
                    this.img.src = "/ChessWeb/Chessboard.png";
                }

                draw() {
                    context.drawImage(this.img, this.position.x, this.position.y, this.size.width, this.size.height);
                }

                update() { }

                addChess(chess) {
                    for(let e of this.dictOfChess){
                        if(e[1].id === chess.id) return;
                    }
                    this.dictOfChess.set(chess.id, chess);
                }
            }

            class Chess {
                constructor(table, tPosition, side, id) {
                    this.id = id;

                    this.table = table;
                    this.size = { width: table.size.width / 8, height: table.size.height / 8 };

                    this.tablePos = new Vector(tPosition.x, tPosition.y);///

                    this.oldCanvasPos = getCanvasPosition(this, tPosition);
                    this.canvasPosition = getCanvasPosition(this, tPosition);

                    //пропорция координат фигуры относительно координат стола, нужная для обмена координатами между хостами с разными размерами мониторов
                    this.relativeFromTablePosition = getRelativeFromTablePosition(this);

                    this.side = side;

                    this.table.addChess(this);

                    this.img = new Image();
                    this.imgIsLoaded = false;
                    this.img.onload = () => {
                        this.imgIsLoaded = true;
                    }
                }

                draw() {
                    if (this.imgIsLoaded)
                        context.drawImage(this.img, this.canvasPosition.x, this.canvasPosition.y, this.size.width, this.size.height);
                }

                update() { }
            }

            class Pawn extends Chess {
                constructor(table, tPosition, side, id) {
                    super(table, tPosition, side, id);
                    if (side === "Black") {
                        this.img.src = "/ChessWeb/PeshkaB.png";
                    }
                    else {
                        this.img.src = "/ChessWeb/PeshkaW.png";
                    }
                }

                    allowedShift(shift_x, shift_y){
                        //если пешка никуда не ходит
                        if (shift_x === 0 && shift_y === 0)
                        return true;
                        //ходы в бок, назад, либо вперед более чем на 1 клетку недопустимы
                        if ((Math.abs(shift_x) > 0 && shift_y === 0) || shift_y > 1 || shift_y < 0)
                        return false;
                        //двинуться по диагонали если есть фигура и она враг
                        else if (shift_x !== 0 && shift_y !== 0 &&
                        Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x + shift_x) && (a.tablePos.y === this.tablePos.y + shift_y))){
                        if(Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x + shift_x) && (a.tablePos.y === this.tablePos.y + shift_y)).side !== this.side)
                        return true;
                        else
                        return false;
                        }
                        //двинуться вперед если никого нет
                        else if (shift_x === 0 && shift_y !== 0 &&
                        !(Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y + shift_y)))){
                        return true;
                        }
                        else return false;
                    }
            }

            class Queen extends Chess {
                constructor(table, tPosition, side, id) {
                    super(table, tPosition, side, id);
                    if (side === "Black") {
                        this.img.src = "/ChessWeb/QueenB.png";
                    }
                    else {
                        this.img.src = "/ChessWeb/QueenW.png";
                    }
                }

                allowedShift(shift_x, shift_y) {
                    //если ход не по диагонали
                    if ((Math.abs(shift_x) !== Math.abs(shift_y)) && (shift_x !== 0 && shift_y !== 0))
                        return false;
                    if (shift_x === 0 && shift_y === 0)
                        return true;


                    //анализ маршрута вниз от движемой фигуры
                    let move_distance_down = 0;
                    if (shift_y > 0 && shift_x === 0) {
                        for (let i = this.tablePos.y; i < 8 && move_distance_down < Math.abs(shift_y); i++) {
                            move_distance_down += 1;
                            if (Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y + move_distance_down))) {
                                //move_distance_down--;
                                break;
                            }
                        }
                        if (shift_y <= move_distance_down &&
                            !Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y + move_distance_down))) {
                            return true;
                        }
                        else if (shift_y <= move_distance_down &&
                            Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y + move_distance_down)).side !== this.side)
                            return true;
                    }

                    //анализ маршрута вверх от движемой фигуры
                    let move_distance_up = 0;
                    if (shift_y < 0 && shift_x === 0) {
                        for (let i = this.tablePos.y; i > 0 && move_distance_up < Math.abs(shift_y); i--) {
                            move_distance_up += 1;
                            if (Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y - move_distance_up))) {
                                //move_distance_up--;
                                break;
                            }
                        }
                        if (Math.abs(shift_y) <= move_distance_up &&
                            !Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y - move_distance_up))) {
                            return true;
                        }
                        else if (Math.abs(shift_y) <= move_distance_up &&
                            Array.from(this.table.dictOfChess.values()).find(a => (a.tablePos.x === this.tablePos.x) && (a.tablePos.y === this.tablePos.y - move_distance_up)).side !== this.side)
                            return true;
                    }
                    /*
                            //анализ маршрута вправо от движемой фигуры
                            int move_distance_right = 0;
                            if (shift_y > 0){
                                while (this.y + move_distance_right < this.chess_Board.GetLength(1) - 1){
                                    move_distance_right++;
                                    if (this.chess_Board[this.x, this.y + move_distance_right] != null){
                                        if (this.chess_Board[this.x, this.y + move_distance_right].side == this.side)
                                            move_distance_right--;
                                        break;
                                    }
                                }
                                if (shift_y <= move_distance_right) return true;
                            }

                            //анализ маршрута влево от движемой фигуры
                            int move_distance_left = 0;
                            if (shift_y < 0){
                                while (this.y + move_distance_left > 0){
                                    move_distance_left--;
                                    if (this.chess_Board[this.x, this.y + move_distance_left] != null){
                                        if (this.chess_Board[this.x, this.y + move_distance_left].side == this.side)
                                            move_distance_left++;
                                        break;
                                    }
                                }
                                if (shift_y >= move_distance_left) return true;
                            }

                                //анализ маршрута вниз вправо от движемой фигуры
                            move_distance_down = 0;
                            move_distance_right = 0;
                            if (shift_x > 0 && shift_y > 0)
                            {
                                while (this.x + move_distance_down < this.chess_Board.GetLength(0) - 1 &&
                                        this.y + move_distance_right < this.chess_Board.GetLength(1) - 1)
                                {
                                    move_distance_down++;
                                    move_distance_right++;
                                    if (this.chess_Board[this.x + move_distance_down, this.y + move_distance_right] != null)
                                    {
                                        if (this.chess_Board[this.x + move_distance_down, this.y + move_distance_right].side == this.side)
                                        {
                                            move_distance_down--;
                                            move_distance_right--;
                                        }
                                        break;
                                    }
                                }
                                if (shift_x <= move_distance_down && shift_y <= move_distance_right) return true;
                            }

                            //анализ маршрута вниз влево от движемой фигуры
                            move_distance_down = 0;
                            move_distance_left = 0;
                            if (shift_x > 0 && shift_y < 0)
                            {
                                while (this.x + move_distance_down < this.chess_Board.GetLength(0) - 1 &&
                                        this.y + move_distance_left > 0)
                                {
                                    move_distance_down++;
                                    move_distance_left--;
                                    if (this.chess_Board[this.x + move_distance_down, this.y + move_distance_left] != null)
                                    {
                                        if (this.chess_Board[this.x + move_distance_down, this.y + move_distance_left].side == this.side)
                                        {
                                            move_distance_down--;
                                            move_distance_left++;
                                        }
                                        break;
                                    }
                                }
                                if (shift_x <= move_distance_down && shift_y >= move_distance_left) return true;
                            }

                            //анализ маршрута вверх влево от движемой фигуры
                            move_distance_up = 0;
                            move_distance_left = 0;
                            if (shift_x < 0 && shift_y < 0)
                            {
                                while (this.x + move_distance_up > 0 &&
                                        this.y + move_distance_left > 0)
                                {
                                    move_distance_up--;
                                    move_distance_left--;
                                    if (this.chess_Board[this.x + move_distance_up, this.y + move_distance_left] != null)
                                    {
                                        if (this.chess_Board[this.x + move_distance_up, this.y + move_distance_left].side == this.side)
                                        {
                                            move_distance_up++;
                                            move_distance_left++;
                                        }
                                        break;
                                    }
                                }
                                if (shift_x >= move_distance_up && shift_y >= move_distance_left) return true;
                            }

                            //анализ маршрута вверх вправо от движемой фигуры
                            move_distance_up = 0;
                            move_distance_right = 0;
                            if (shift_x < 0 && shift_y > 0)
                            {
                                while (this.x + move_distance_up > 0 &&
                                        this.y + move_distance_right < this.chess_Board.GetLength(1) - 1)
                                {
                                    move_distance_up--;
                                    move_distance_right++;
                                    if (this.chess_Board[this.x + move_distance_up, this.y + move_distance_right] != null)
                                    {
                                        if (this.chess_Board[this.x + move_distance_up, this.y + move_distance_right].side == this.side)
                                        {
                                            move_distance_up++;
                                            move_distance_right--;
                                        }
                                        break;
                                    }
                                }
                                if (shift_x >= move_distance_up && shift_y <= move_distance_right) return true;
                            } */

                    return false;
                }
            }

            function getRelativeFromTablePosition(chess){
                let relativeX = (chess.canvasPosition.x - chess.table.position.x) / chess.table.size.width;
                let relativeY = (chess.canvasPosition.y - chess.table.position.y) / chess.table.size.height;
                return new Vector(relativeX, relativeY);
            }

            function getCanvasPosition(chess, tPosition) {
                let x = tPosition.x * chess.size.width + chess.table.position.x;
                let y = tPosition.y * chess.size.height + chess.table.position.y;
                return new Vector(x, y);
            }

            function getCursorTablePosition(chess, cursorPos) {
                let x = Math.floor((cursorPos.x - chess.table.position.x) / chess.size.width);
                let y = Math.floor((cursorPos.y - chess.table.position.y) / chess.size.height);
                return new Vector(x, y);
            }

            let table = new Table();

            new Pawn(table, new Vector(3, 1), "White", 0);
            new Pawn(table, new Vector(2, 1), "White", 1);
            new Pawn(table, new Vector(2, 6), "Black", 2);
            new Queen(table, new Vector(3, 4), "Black", 3);
            //new King(table, new Vector(4, 5), "White", 4);

            let moveCount = 0;
            canvas.addEventListener("mousedown", mouseDown);
            function mouseDown(event) {
                if(GameState === "ActiveLeading" && moveCount === 0){
                    let targetObj;//захваченный объект
                    let mousePosInObj;//координаты курсора внутри объекта относительно его верхнего левого угла

                    //перебираем объекты из массива объектов-шахмат в объекте доски и выполняем ивент для шахматы на которую указывает курсор
                    for(let pairIdChess of table.dictOfChess){
                        if(event.clientX > pairIdChess[1].canvasPosition.x &&
                        event.clientX < pairIdChess[1].canvasPosition.x + pairIdChess[1].size.width &&
                        event.clientY > pairIdChess[1].canvasPosition.y &&
                        event.clientY < pairIdChess[1].canvasPosition.y + pairIdChess[1].size.height){

                            targetObj = pairIdChess[1];
                            if (PlayerSide !== targetObj.side) break;

                            targetObj.oldCanvasPos.x = targetObj.canvasPosition.x;
                            targetObj.oldCanvasPos.y = targetObj.canvasPosition.y;

                            mousePosInObj = {
                                dx: event.clientX - targetObj.canvasPosition.x,
                                dy: event.clientY - targetObj.canvasPosition.y
                            };
                            canvas.addEventListener("mousemove", mouseMove);
                            canvas.addEventListener("mouseup", mouseUp);
                        }
                    }

                    function mouseMove(event) {
                        targetObj.relativeFromTablePosition.x = (event.clientX - targetObj.table.position.x - mousePosInObj.dx) / targetObj.table.size.width;
                        targetObj.relativeFromTablePosition.y = (event.clientY - targetObj.table.position.y - mousePosInObj.dy) / targetObj.table.size.height;

                        targetObj.canvasPosition.x = targetObj.table.position.x + targetObj.relativeFromTablePosition.x * targetObj.table.size.width;
                        targetObj.canvasPosition.y = targetObj.table.position.y + targetObj.relativeFromTablePosition.y * targetObj.table.size.height;

                        if (GameState === "ActiveWaiting") {//на всякий случай
                            canvas.removeEventListener("mousemove", mouseMove);
                            canvas.removeEventListener("mouseup", mouseUp);

                            targetObj.relativeFromTablePosition.x = (targetObj.oldCanvasPos.x - targetObj.table.position.x) / targetObj.table.size.width;
                            targetObj.relativeFromTablePosition.y = (targetObj.oldCanvasPos.y - targetObj.table.position.y) / targetObj.table.size.height;

                            targetObj.canvasPosition.x = targetObj.table.position.x + targetObj.relativeFromTablePosition.x * targetObj.table.size.width;
                            targetObj.canvasPosition.y = targetObj.table.position.y + targetObj.relativeFromTablePosition.y * targetObj.table.size.height;
                        }
                    }

                    function mouseUp(event) {
                        canvas.removeEventListener("mousemove", mouseMove);
                        canvas.removeEventListener("mouseup", mouseUp);

                        //по текущим координатам захваченной фигуры определяем над какой ячейкой она находится
                        let tPos = getCursorTablePosition(targetObj, new Vector(event.clientX, event.clientY));
                        let cPos = getCanvasPosition(targetObj, tPos);//вычисляем координаты этой ячейки
                        let shift = {//смещение относительно изначального положения
                            dx: tPos.x - targetObj.tablePos.x,
                            dy: tPos.y - targetObj.tablePos.y
                        };

                        //если объект отпускают в исходной клетке, то его возвращает в исходную позицию
                        if (event.clientX > targetObj.oldCanvasPos.x && event.clientX < targetObj.oldCanvasPos.x + targetObj.size.width &&
                            event.clientY > targetObj.oldCanvasPos.y && event.clientY < targetObj.oldCanvasPos.y + targetObj.size.height) {
                            targetObj.relativeFromTablePosition.x = (targetObj.oldCanvasPos.x - targetObj.table.position.x) / targetObj.table.size.width;
                            targetObj.relativeFromTablePosition.y = (targetObj.oldCanvasPos.y - targetObj.table.position.y) / targetObj.table.size.height;

                            targetObj.canvasPosition.x = targetObj.table.position.x + targetObj.relativeFromTablePosition.x * targetObj.table.size.width;
                            targetObj.canvasPosition.y = targetObj.table.position.y + targetObj.relativeFromTablePosition.y * targetObj.table.size.height;
                        }
                        //если объект отпускают за пределами доски, то его возвращает в исходную позицию
                        else if (!(event.clientX > table.position.x && event.clientY > table.position.y &&
                            event.clientX < table.position.x + table.size.width && event.clientY < table.position.y + table.size.height)) {
                            targetObj.relativeFromTablePosition.x = (targetObj.oldCanvasPos.x - targetObj.table.position.x) / targetObj.table.size.width;
                            targetObj.relativeFromTablePosition.y = (targetObj.oldCanvasPos.y - targetObj.table.position.y) / targetObj.table.size.height;

                            targetObj.canvasPosition.x = targetObj.table.position.x + targetObj.relativeFromTablePosition.x * targetObj.table.size.width;
                            targetObj.canvasPosition.y = targetObj.table.position.y + targetObj.relativeFromTablePosition.y * targetObj.table.size.height;
                        }
                        //проверка на возможность сходить в данную клетку данной фигурой
                        else if (!targetObj.allowedShift(shift.dx, shift.dy)) {
                            targetObj.relativeFromTablePosition.x = (targetObj.oldCanvasPos.x - targetObj.table.position.x) / targetObj.table.size.width;
                            targetObj.relativeFromTablePosition.y = (targetObj.oldCanvasPos.y - targetObj.table.position.y) / targetObj.table.size.height;

                            targetObj.canvasPosition.x = targetObj.table.position.x + targetObj.relativeFromTablePosition.x * targetObj.table.size.width;
                            targetObj.canvasPosition.y = targetObj.table.position.y + targetObj.relativeFromTablePosition.y * targetObj.table.size.height;
                        }
                        //если за мгновение до отпускания шахматы закончился ход(опять на всякий случай)
                        else if (GameState === "ActiveWaiting") {
                            targetObj.relativeFromTablePosition.x = (targetObj.oldCanvasPos.x - targetObj.table.position.x) / targetObj.table.size.width;
                            targetObj.relativeFromTablePosition.y = (targetObj.oldCanvasPos.y - targetObj.table.position.y) / targetObj.table.size.height;

                            targetObj.canvasPosition.x = targetObj.table.position.x + targetObj.relativeFromTablePosition.x * targetObj.table.size.width;
                            targetObj.canvasPosition.y = targetObj.table.position.y + targetObj.relativeFromTablePosition.y * targetObj.table.size.height;
                        }
                        //если объект можно вставить в данную ячейку, то удаляем из этой ячейки(через массив в объекте доски) объект фигуры и
                        //меняем координаты текущей фигуры на координаты этой ячейки
                        else {
                            let idOfChessToDelete;
                            for(let pairIdChess of targetObj.table.dictOfChess){
                                if(pairIdChess[1].tablePos.x === tPos.x && pairIdChess[1].tablePos.y === tPos.y){
                                    idOfChessToDelete = pairIdChess[0];
                                    targetObj.table.dictOfChess.delete(idOfChessToDelete);
                                    break;
                                }
                            }

                            targetObj.tablePos.x = tPos.x;
                            targetObj.tablePos.y = tPos.y;
                            targetObj.canvasPosition.x = cPos.x;
                            targetObj.canvasPosition.y = cPos.y;
                            targetObj.oldCanvasPos.x = targetObj.canvasPosition.x;
                            targetObj.oldCanvasPos.y = targetObj.canvasPosition.y;

                            targetObj.relativeFromTablePosition = getRelativeFromTablePosition(targetObj);

                            moveCount++;
                        }
                    }
                }
            }

            //Animation------------------------------------------------------------------
            function updateCanvas() {

                context.clearRect(0, 0, canvas.width, canvas.height)

                table.draw();
                if (table.update)
                    table.update();

                for(let pairIdChess of table.dictOfChess){
                    //отрисовывает объект
                    pairIdChess[1].draw();
                    //обновляет состояние объекта если внутри есть соответствующий метод
                    if(pairIdChess[1].update)
                        pairIdChess[1].update();
                }

                //TESTS
                context.fillText("Player state: " + GameState, 20, 140);
                context.fillText("Side: " + PlayerSide, 20, 150);
                context.fillText("Response: " + parsedResponse.get("TableState").toString(), 20, 160);
                //if (table.dictOfChess.has(1)) {
                //    context.fillText("Pawn1: " + table.dictOfChess.get(1).relativeFromTablePosition.x +
                //        " " + table.dictOfChess.get(1).relativeFromTablePosition.y, 20, 150);
                //    context.fillText("Pawn1: " + table.dictOfChess.get(1).oldCanvasPos.x +
                //        " " + table.dictOfChess.get(1).oldCanvasPos.y, 20, 160);
                //    context.fillText("Pawn1: " + table.dictOfChess.get(1).canvasPosition.x +
                //        " " + table.dictOfChess.get(1).canvasPosition.y, 20, 170);
                //}
                //if (table.dictOfChess.has(3)) {
                //    context.fillText("Queen1: " + table.dictOfChess.get(3).relativeFromTablePosition.x +
                //        " " + table.dictOfChess.get(3).relativeFromTablePosition.y, 20, 190);
                //    context.fillText("Queen1: " + table.dictOfChess.get(3).oldCanvasPos.x +
                //        " " + table.dictOfChess.get(3).oldCanvasPos.y, 20, 200);
                //    context.fillText("Queen1: " + table.dictOfChess.get(3).canvasPosition.x +
                //        " " + table.dictOfChess.get(3).canvasPosition.y, 20, 210);
                //}

                requestAnimationFrame(updateCanvas);
            }

            //WebScoket logic------------------------------------------------------------
            let ip = "@ViewBag.Ip";
            let port = "@ViewBag.PORT";
            let socket = new WebSocket("ws://" + ip + ":" + port);


            let BSide = "Side:" + PlayerSide + "<delimiter>";
            let BPlayerState = "PlayerState:WaitBegining<delimiter>";
            let BIsCheckmate = "IsCheckmate:false<delimiter>";
            let BTableState = "TableState:" + buildChessPositions() + "<delimiter>";

            let tempString = BSide + BPlayerState + BIsCheckmate + BTableState;
            let parsedResponse = parseResponse(tempString);
            let request = buildRequest(parsedResponse);

            socket.onopen = function (event) {
                socket.send(request + "\r\n\r\n");
            };
            socket.onmessage = function (event) {
                parsedResponse = parseResponse(event.data);

                if (parsedResponse.get("PlayerState") === "ActiveLeading")
                    continueButton.disabled = false;
                else
                    continueButton.disabled = true;

                updateStates(parsedResponse);

                if (GameState === "ActiveWaiting") {
                    moveCount = 0;
                    updateChess(parsedResponse);
                }
                if (GameState === "ActiveLeading")
                    parsedResponse.set("TableState", buildChessPositions());
                if (GameState === "Loser") {
                    alert("You lose, gg");
                    socket.close();
                }
                if (GameState === "Winner") {
                    alert("You win, graz");
                    socket.close();
                }
                if (GameState === "Disconnected") {
                    alert("You opponent disconnected");
                    socket.close();
                }

                socket.send(buildRequest(parsedResponse) + "\r\n\r\n");
            };
            socket.onclose = function (event) {
                if (event.wasClean) {
                    alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
                }
                else {
                    // например, сервер убил процесс или сеть недоступна
                    // обычно в этом случае event.code 1006
                    alert('[close] Соединение прервано');
                }
            };
            socket.onerror = function (error) {
                alert(`[error] ${error.message}`);
            };

            function parseResponse(response) {
                //Header1:blabla1<delimiter>Header2:blabla2<delimiter>...<delimiter> -> (Header1:blabla1)(Header2:blabla2)...
                let tempReq = response.split("<delimiter>");
                let dict = new Map();
                let temp1 = null;
                for (let i = 0; i < tempReq.length; i++) {
                    temp1 = tempReq[i].split(":");
                    dict.set(temp1[0], temp1[1]);
                }
                return dict;
            }

            function updateChess(parsedResponse) {
                let chessStrings = (parsedResponse.get("TableState")).split(";");
                chessStrings.splice(chessStrings.length - 1, 1);

                let dictIdChessRelCoord = new Map();//(id: {relX, relY})
                for (let e of chessStrings) {
                    let IdXY = e.match(/[0-9]+\.*[0-9]*/gi);
                    dictIdChessRelCoord.set(Number(IdXY[0]), {
                        relX: Number(IdXY[1]),
                        relY: Number(IdXY[2])});
                }

                for (let pairIdChess of table.dictOfChess) {
                    if (!dictIdChessRelCoord.has(pairIdChess[0])) {
                        table.dictOfChess.delete(pairIdChess[0]);
                    }
                    else {
                        pairIdChess[1].relativeFromTablePosition.x = dictIdChessRelCoord.get(pairIdChess[0]).relX;
                        pairIdChess[1].relativeFromTablePosition.y = dictIdChessRelCoord.get(pairIdChess[0]).relY;

                        pairIdChess[1].canvasPosition.x = pairIdChess[1].table.position.x + pairIdChess[1].relativeFromTablePosition.x * pairIdChess[1].table.size.width;
                        pairIdChess[1].canvasPosition.y = pairIdChess[1].table.position.y + pairIdChess[1].relativeFromTablePosition.y * pairIdChess[1].table.size.height;

                        pairIdChess[1].oldCanvasPos.x = pairIdChess[1].canvasPosition.x;
                        pairIdChess[1].oldCanvasPos.y = pairIdChess[1].canvasPosition.y;

                        pairIdChess[1].tablePos.x = Math.floor((pairIdChess[1].canvasPosition.x - pairIdChess[1].table.position.x) / pairIdChess[1].size.width);
                        pairIdChess[1].tablePos.y = Math.floor((pairIdChess[1].canvasPosition.y - pairIdChess[1].table.position.y) / pairIdChess[1].size.height);
                    }
                }
            }

            function buildChessPositions() {
                let result = "";
                for (let pairIdChess of table.dictOfChess) {
                    let relCoordinates = pairIdChess[1].relativeFromTablePosition;
                    result += "(" + pairIdChess[0] + "," + relCoordinates.x.toString() + "," + relCoordinates.y.toString() + ");";
                }
                return result;
            }

            function buildRequest(subRequests) {
                let result = "";
                result += "Side:" + subRequests.get("Side") + "<delimiter>";
                result += "PlayerState:" + subRequests.get("PlayerState") + "<delimiter>";
                result += "IsCheckmate:" + subRequests.get("IsCheckmate") + "<delimiter>";
                result += "TableState:" + subRequests.get("TableState") + "<delimiter>";
                return result;
            }

            function updateStates(parsedResponse) {
                GameState = parsedResponse.get("PlayerState");
                PlayerSide = parsedResponse.get("Side");
            }

            //Click button to continue--------------------------------------
            let continueButton = document.querySelector(".button1");
            continueButton.addEventListener("click", nextMove);
            async function nextMove() {
                let url = "http://" + document.location.host + "/Game/NextMove";
                let response = await fetch(url);

                if (response.ok) { // если HTTP-статус в диапазоне 200-299
                    let str = await response.text();
                } else {
                    alert("Ошибка HTTP: " + response.status);
                }
            }

            //Click button to surrender--------------------------------------
            let surrenderButton = document.querySelector(".button2");
            surrenderButton.addEventListener("click", surrender);
            async function surrender() {
                let url = "http://" + document.location.host + "/Game/Surrender";
                let response = await fetch(url);

                if (response.ok) { // если HTTP-статус в диапазоне 200-299
                    let str = await response.text();
                } else {
                    alert("Ошибка HTTP: " + response.status);
                }
            }

            window.onclose = function () { socket.close(); } 
            window.onunload = function () { socket.close(); } 

            //let reloaded = function () { socket.close(); }
            //window.onload = function () {
            //    let loaded = sessionStorage.getItem('loaded');
            //    if (loaded) {
            //        reloaded();
            //    } else {
            //        sessionStorage.setItem('loaded', true);
            //    }
            //}

            //--------------------------------------------------------------
            updateCanvas();
        }
    </script>
</body>
</html>
